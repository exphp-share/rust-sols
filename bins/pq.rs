extern crate serde_json;
extern crate serde;
#[macro_use]
extern crate serde_derive;

fn gcd(a: i64, b: i64) -> i64 {
  let mut a = a.abs();
  let mut b = b.abs();
  while b != 0 {
    let t = b;
    b = a % b;
    a = t;
  }
  a
}

fn angle_degrees((a,b,c): (i64,i64,i64)) -> f64 {
  if (a,b,c) == (1, 1, 2) { 60.0 }
  else { f64::acos(a as f64 / c as f64) * 180.0 / ::std::f64::consts::PI }
}

fn letter((a,b,c): (i64,i64,i64)) -> char {
  let angle = angle_degrees((a,b,c));
  if 0. <= angle && angle < 30.0 { 'a' }
  else if 30. < angle && angle <= 60.0 { 'b' }
  else if 60. < angle && angle < 90.0 { 'c' }
  else { panic!() }
}

fn letter_2((a,b,c): (i64,i64,i64)) -> char {
  if ((f64::sqrt(3.0)*b as f64) / c as f64) < 0.5 { 'a' } else { 'b' }
}

fn pq_letter((p,q): (i64,i64)) -> char {
  if (p as f64) < 3.0 / (2.0 * f64::sqrt(3.0) + 3.0) * q as f64 { 'a' } else { 'b' }
}

// Demonstrates that (p,q) is a superior representation to (a,b,c):
//
// - All coprime pairs p <= q are solutions.  (Finding (a,b,c) sols requires searching)
// - Every solution with theta < 60 degrees is still generated exactly once.
// - The solutions with theta > 60 degrees are not generated.
//   (those correspond to p > q, or b > a)
// - For a given max supercell size, there still exists:
//   - a hard upper bound on q (for arbitrary p)
//   - a hard upper bound on p (for a given q)
//   (the number of cells is at least c/2, and c is at least (3q^2 + p^2)/6)
fn main() {
  use ::std::collections::HashMap;

  let square = |x| x*x;

  let sols: Vec<(i64, i64, i64)> = ::serde_json::from_reader(::std::fs::File::open("sols.json").unwrap()).unwrap();
  let mut map = HashMap::new();
  for (a,b,c) in sols {
    // Shows that the 'c' sols are exactly those sols where b > a  (correspondingly p > q)
    assert_eq!(b > a, letter((a,b,c)) == 'c');
    if letter((a,b,c)) != 'c' {
      map.insert((a,b,c), None);
    }
  }
  let mut gammas = HashMap::new();
  let mut area_factors = HashMap::new(); // factors of cg / area
  for q in 0.. {
    let mut min_c = ::std::i64::MAX;
    let mut max_c = 0;
    for p in 0..=q {
      if gcd(p, q) != 1 {
        continue;
      }
      let ag = 3*q*q - p*p;
      let bg = 2*q*p;
      let cg = 3*q*q + p*p;
      let g = gcd(gcd(ag, bg), cg);
      let a = ag / g;
      let b = bg / g;
      let c = cg / g;
      let gamma = gcd(3*q+p, 3*q-p);
      assert_eq!(gamma, g);
      *gammas.entry(gamma).or_insert(0) += 1;
      min_c = min_c.min(c);
      max_c = max_c.max(c);
      assert!(g == 2 || g == 1 || g == 3 || g == 6);
      let letter = letter((a,b,c));
//      println!("{:?}", ((a,b,c),(p,q)));
      assert!(letter == 'a' || letter == 'b');
      assert_eq!(letter, letter_2((a,b,c)), "{}", angle_degrees((a,b,c)));
      assert_eq!(letter, pq_letter((p,q)), "{}", angle_degrees((a,b,c)));

      //let z = match (q % 2, p % 2) {
      //  (1, 1) => 2,
      //  _ => 1,
      //};
      assert_eq!(gamma, 2 * gcd(p, 3) / gcd(p*q, 2));

      let area = if c%2==0 {c/2} else {c};
      assert_eq!(cg % area, 0);
      *area_factors.entry(cg / area).or_insert(0) += 1;

      assert_eq!(cg / area, square(2/gcd(p*q, 2)) * gcd(p, 3));

      if let Some(old) = map.remove(&(a,b,c)) {
        // Shows that each (a,b,c) is generated by AT MOST one coprime pair 0 <= p <= q
        assert!(old.is_none());
        map.insert((a, b, c), Some((p, q, letter)));

        println!("{:?}, {}, {:?}, {:.3}", (a,b,c), area, (p,q, letter), angle_degrees((a,b,c)));
      } else {
        // assume area is too large for it to be in the json
//        println!("{:?}", (a,b,c));
      }
  //    println!("({},{}) -> {} * ({},{},{}) {}", p, q, g, a, b, c, letter)
    }
 //   println!("q = {:?}, c = {} to {}", q, min_c, max_c);
    if q % 1000 == 0 {
      let remaining = map.values().filter(|x| x.is_none()).count();
      println!("q = {}, {} remaining", q, remaining);
      if remaining == 0 { break; }
    }
  }

  // Shows that each (a,b,c) is generated by AT LEAST one coprime pair 0 <= p <= q
  let mut map = map.into_iter().collect::<Vec<_>>();
  map.sort_by_key(|&((a,b,c), _)| (c, a, b));
  for ((a, b, c), value) in map.into_iter().filter(|(k,v)| v.is_none()) {
      println!("No (p,q) for {:?} ({:?})", (a,b,c), letter((a,b,c)));
  }
  println!("gammas: {:?}", gammas);
  println!("area_factors: {:?}", area_factors);
}
