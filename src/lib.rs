extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate num_rational;
use num_rational::Rational64;

pub fn gcd(a: i64, b: i64) -> i64 {
  let mut a = a.abs();
  let mut b = b.abs();
  while b != 0 {
    let t = b;
    b = a % b;
    a = t;
  }
  a
}

pub fn isqrt(x: i64) -> Option<i64> {
    // i64 might not fit entirely in the f64 mantissa.
    // (but if it does, then the square root clearly also fits)
    if x < 0 {
        return None;
    }
    assert_eq!(x as f64 as i64, x, "number too big for f64");
    // assuming IEEE-754 compliance, no rounding is necessary
    let r = f64::sqrt(x as f64) as i64;
    if r * r == x {
        Some(r)
    } else {
        None
    }
}

pub fn qsqrt(x: Rational64) -> Option<Rational64> {
    let numer = isqrt(*x.numer())?;
    let denom = isqrt(*x.denom())?;
    Some(Rational64::new_raw(numer, denom))
}

pub fn div_exact(a: i64, b: i64) -> Option<i64> {
    if a % b == 0 {
        Some(a / b)
    } else {
        None
    }
}

/// a solution for beta = 3, r = 1
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[derive(Serialize)]
pub struct Triple(pub i64, pub i64, pub i64);
impl Triple {
    pub fn validate_new(a: i64, b: i64, c: i64) -> Self {
        assert!(a >= 0 && b >= 0 && c >= 0);
        assert_eq!(gcd(a, b), 1);
        assert_eq!(gcd(a, c), 1);
        assert_eq!(a*a + 3*b*b, c*c);
        Triple(a, b, c)
    }

    pub fn checked_new(a: i64, b: i64, c: i64) -> Option<Self> {
        if a < 0 || b < 0 || c < 0 { return None; }
        if gcd(a, b) != 1 { return None; }
        if gcd(a, c) != 1 { return None; }
        if a*a + 3*b*b != c*c { return None; }
        Some(Self::validate_new(a, b, c))
    }

    pub fn checked_from_ac(a: i64, c: i64) -> Option<Self> {
        let quot = i64::checked_div(c*c - a*a, 3)?;
        let root = isqrt(quot)?;
        Self::checked_new(a, root, c)
    }
}

impl Triple {
    pub fn angle(&self) -> f64 {
        let &Triple(a,_,c) = self;
        f64::acos(a as f64 / c as f64)
    }

    pub fn angle_degrees(&self) -> f64 {
        self.angle() * 180.0 / ::std::f64::consts::PI
    }

    pub fn letter(&self) -> char {
        let angle = self.angle_degrees();
        if self == &Triple(1, 1, 2) { 'b' } // exactly 60.0, but can't trust f64 due to division by PI
        else if 0. <= angle && angle < 30. { 'a' }
        else if 30. < angle && angle < 60. { 'b' }
        else if 60. < angle && angle <= 90. { 'c' } // undesirable, identical to an 'a' solution
        else { panic!() }
    }

    pub fn volume(&self) -> i64 {
        // -----------------------------------------------------
        // The definition of volume for solutions with beta = 3, r = 1   (bilayer graphene sheets of equal bond length)
        // -----------------------------------------------------

        // This is proven in 10.1103/PhysRevB.81.165105, though written differently.
        //
        // As an aside, their formalism differs in rather interesting ways from my own;

        // * when they obtain the diophantine equation 3*i1**2 + i2**2 == i3**2 they do not
        //   require that (i1, i2, i3) are coprime.  In fact, their final solution is that
        //   there is a 1-1 correspondence between solutions in [0.0, 60.0] and coprime (p,q)
        //   pairs (0 <= p <= q), with
        //
        //     i1 = 2pq
        //     i2 = 3*q**2 - p**2
        //     i3 = 3*q**2 + p**2
        //
        //   which clearly has solutions where gcd(i1, i2, i3) > 1.
        //   (contrast with my (a, b, c) with are mutually coprime)
        //
        //   They additionally define   gamma = gcd(3*q - p, 3*q + p)
        //                        and   delta = 3 / gcd(p, 3)
        //
        //   which appear in their definition of the volume:
        //                N = (3 / delta) (1 / gamma**2) i3      (their (15))

        // * After repeated attempts I am unable to make sense of what happens between their
        //   equations (10) and (11) (where they perform a similarity transform).
        //
        //   So I have verified the following by brute force on all solutions with c <= 10000
        //   by observing all coprime (p, q) pairs with 0 <= p <= q <= 1000.
        //
        //   For each (p, q), define (a, b, c) as `(i2, i1, i3)/gcd(i1, i2, i3)`.  Then:
        //
        //   - Every (a, b, c) solution with angle in [0.0, 60.0] (angle defined as acos(a/c))
        //     is generated by one, and only one, (p, q).
        //   - Every (a, b, c) solution generated by a (p, q) pair is a solution in [0.0, 60.0]
        //     (as opposed to one in [60.0, 90.0], which my formalism unhelpfully allows)
        //   - gcd(i1, i2, i3) = gamma.
        //   - gamma is always in the set {1, 2, 3, 6}
        //   - (by the above two)  gamma = gcd(p, 3) * psi
        //                           psi = 2 if (p == q == 1 (mod 2))
        //                               = 0 otherwise
        //   - Substituting into the volume:  N = (3 / delta) (1 / gamma**2) i3
        //                                      = (3 / delta) (1 / gamma) c
        //                                      = c / psi

        // Finally leading to the following:
        //
        //    The volume v of a solution with r == 1 is always equal to c or c / 2;
        //    whichever one is the odd integer.
        let &Triple(_, _, c) = self;
        assert!(c < 100_000, "c exceeds bound verified by brute force");
        if c % 2 == 0 { c / 2 } else { c }
    }
}
